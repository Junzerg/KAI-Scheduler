# Reclaim 与 Preempt 走读

本文梳理 KAI Scheduler 中两个「破坏性」调度动作：**Reclaim（回收）** 与 **Preempt（抢占）**。二者均通过驱逐（Evict）已有 Pod 为待调度 Job 腾出资源，但作用域与策略不同。

参考文档：`docs/developer/action-framework-zh.md`、`docs/fairness/README.md`、`docs/queues/README.md`。

---

## 1. Reclaim 与 Preempt 的定位

### 1.1 在 Action 链中的顺序

根据 `action-framework-zh.md`，调度周期内 Action 执行顺序为：

| 顺序 | Action            | 作用域                 | 干扰程度 |
| ---- | ----------------- | ---------------------- | -------- |
| 1    | Allocate          | 无                     | 无       |
| 2    | Consolidate       | 同队列                 | 低       |
| 3    | **Reclaim**       | **跨队列**             | 中       |
| 4    | **Preempt**       | **同队列**             | 高       |
| 5    | StaleGangEviction | 违反 minMember 的 gang | 高       |

### 1.2 核心区别

| 维度            | Reclaim                                    | Preempt                       |
| --------------- | ------------------------------------------ | ----------------------------- |
| **Victim 来源** | **其他队列**的 Job                         | **同一队列**的 Job            |
| **设计意图**    | 回收「借用」的资源，实现队列间公平         | 队列内按优先级抢占            |
| **典型场景**    | 队列 A 超配额借用，队列 B 有更高优先级需求 | 高优先级 Job 抢占低优先级 Job |
| **Victim 过滤** | `ReclaimVictimFilter`                      | `PreemptVictimFilter`         |
| **场景校验**    | `ReclaimScenarioValidatorFn`               | `PreemptScenarioValidator`    |

---

## 2. 共享的求解框架：JobSolver

Reclaim 与 Preempt 均使用 `actions/common/solvers` 包下的 **JobSolver** 与 **ByPodSolver**，通过「场景模拟」寻找可行解。

### 2.1 整体流程

```
Reclaim/Preempt Execute
    │
    ▼
for each pending Job (按队列顺序):
    │
    ├─ Reclaim: CanReclaimResources(job)?  [仅 Reclaim]
    ├─ Preempt: IsNonPreemptibleJobOverQueueQuotaFn?  [仅 Preempt]
    │
    ▼
solver.Solve(ssn, job)
    │
    ├─ 逐 Task 尝试：从 1 个 Task 到全部 Task
    ├─ 对每个 partialJob：solvePartialJob
    │       │
    │       ├─ ScenarioBuilder 生成 Victim 组合（ByNodeScenario）
    │       ├─ 对每个 Scenario：ByPodSolver.solve
    │       │       │
    │       │       ├─ EvictAllPreemptees（虚拟驱逐 Victim）
    │       │       ├─ TryToVirtuallyAllocatePreemptorAndGetVictims（虚拟分配 Preemptor + 被抢占的 Victim）
    │       │       └─ solutionValidator(scenario) 校验
    │       │
    │       └─ 找到可行解 → 返回 statement
    │
    ▼
statement.Commit()  →  Evict + Allocate 落盘
```

### 2.2 JobSolver.Solve 入口

文件：`pkg/scheduler/actions/common/solvers/job_solver.go`

```go
func (s *JobSolver) Solve(ssn *framework.Session, pendingJob *podgroup_info.PodGroupInfo) (bool, *framework.Statement, []string) {
	tasksToAllocate := podgroup_info.GetTasksToAllocate(pendingJob, ssn.PodSetOrderFn, ssn.TaskOrderFn, false)
	for _, nextTaskToSolve := range tasksToAllocate {
		pendingTasks = append(pendingTasks, nextTaskToSolve)
		partialPendingJob := getPartialJobRepresentative(pendingJob, pendingTasks)
		result := s.solvePartialJob(ssn, &state, partialPendingJob)
		if result != nil && result.solved {
			statement = result.statement
			// ...
		}
	}
	jobSolved := pendingJob.IsGangSatisfied()
	return jobSolved, statement, calcVictimNames(state.recordedVictimsTasks)
}
```

**逐 Task 尝试**：先尝试只分配 1 个 Task，再 2 个、3 个…直到全部分配或失败。支持 gang 的部分满足。

---

## 3. Reclaim 动作详解

文件：`pkg/scheduler/actions/reclaim/reclaim.go`

Reclaim（回收）的核心目标是**跨队列**的资源回收。当某个队列的 Queue 需要使用资源，但资源被其他队列借用时，Reclaim 会介入回收这些借出的资源。

> **[Design: Action Framework]** Reclaim 与 Preempt 的区别：
>
> - **Reclaim**: 跨队列（Cross-Queue），纠正配额借用，维持队列公平性。
> - **Preempt**: 队列内（In-Queue），高优先级抢占低优先级。
> - 执行顺序：Reclaim 优先于 Preempt，优先解决配额/公平性问题。

### 3.1 Execute 主循环：筛选与决策

```go
func (ra *reclaimAction) Execute(ssn *framework.Session) {
	// 1. 获取待调度的任务列表
	jobsOrderByQueues := utils.NewJobsOrderByQueues(ssn, ...)
	jobsOrderByQueues.InitializeWithJobs(ssn.PodGroupInfos)

	for !jobsOrderByQueues.IsEmpty() {
		job := jobsOrderByQueues.PopNextJob()

		// [Design: Plugin Extension] 策略检查
		// 由插件（如 Fairness 插件）决定该 Job 是否符合 "Reclaim" 条件（例如：当前队列使用量 < Min Share）
		if !ssn.CanReclaimResources(job) {
			continue
		}

		// 2. 尝试寻找回收方案
		succeeded, statement, reclaimeeTasksNames := ra.attemptToReclaimForSpecificJob(ssn, job)
		if succeeded {
			// [Design: Transaction] 事务提交
			// 一旦找到可行方案（包括驱逐哪些 Pod、分配到哪个节点），原子性提交
			statement.Commit()
		} else {
			smallestFailedJobs.UpdateRepresentative(job)
		}
	}
}
```

### 3.2 attemptToReclaimForSpecificJob：模拟求解

这里使用了 **Solver（求解器）** 模式，它封装了复杂的“模拟-验证”逻辑。

```go
func (ra *reclaimAction) attemptToReclaimForSpecificJob(ssn *framework.Session, reclaimer *podgroup_info.PodGroupInfo) (bool, *framework.Statement, []string) {
	feasibleNodes := common.FeasibleNodesForJob(maps.Values(ssn.Nodes), reclaimer)

	// [Design: Simulation & Scenarios]
	// Solver 在内存中构建 "Scenario"（场景），模拟驱逐 Victim 并放入 Reclaimer。
	// 它会检查：
	// 1. 驱逐后资源是否足够？
	// 2. 是否满足亲和性/反亲和性？
	// 3. 插件是否允许（ReclaimScenarioValidatorFn）？
	solver := solvers.NewJobsSolver(
		feasibleNodes,
		ssn.ReclaimScenarioValidatorFn,
		getOrderedVictimsQueue(ssn, reclaimer), // 关键：定义谁是受害者
		framework.Reclaim,
	)
	return solver.Solve(ssn, reclaimer)
}
```

### 3.3 getOrderedVictimsQueue：定义跨队列 Victim

这是 Reclaim 逻辑最核心的代码片段，体现了其设计意图。

```go
func getOrderedVictimsQueue(ssn *framework.Session, reclaimer *podgroup_info.PodGroupInfo) solvers.GenerateVictimsQueue {
	return func() *utils.JobsOrderByQueues {
		jobsOrderedByQueue := utils.NewJobsOrderByQueues(ssn, ...)
		jobs := map[common_info.PodGroupID]*podgroup_info.PodGroupInfo{}

		for _, job := range ssn.PodGroupInfos {
			// [Design: Cross-Queue Logic]
			// 核心过滤：如果 Job 同属一个队列，则跳过！
			// 这保证了 Reclaim 只会从【其他队列】抢回资源。
			if job.Queue == reclaimer.Queue {
				continue
			}

			// [Design: Plugin Filter]
			// 进一步过滤，例如：只能抢占低优先级的 Job，或不在此队列 "Reclaimable" 列表中的 Job
			if !ssn.ReclaimVictimFilter(reclaimer, job) {
				continue
			}
			jobs[job.UID] = job
		}
		jobsOrderedByQueue.InitializeWithJobs(jobs)
		return &jobsOrderedByQueue
	}
}
```

**总结**：`job.Queue == reclaimer.Queue` 这一行代码严格界定了 Reclaim 的边界——它只处理**队列间**的资源争夺。队列内的资源争夺留给 `Preempt` Action 处理。

---

## 4. Preempt 动作详解

文件：`pkg/scheduler/actions/preempt/preempt.go`

Preempt（抢占）的核心是**队列内**（In-Queue）的优先级实施。它的目的是确保在同一个队列内，高优先级的作业能够抢占低优先级的作业资源。

> **[Design: Action Framework]** Preempt 的定位：
>
> - 范围：仅发生在**同一队列**内部。
> - 依据：Job 的 Priority。
> - 约束：即使是高优先级，抢占后也不能突破队列的配额限制（Quota）。

### 4.1 Execute 主循环

Exectue 逻辑与 Reclaim 类似，遍历待调度作业，尝试抢占。

```go
func (alloc *preemptAction) Execute(ssn *framework.Session) {
	// ... (初始化 JobsOrderByQueues 和 SchedulingSignatures)

	for !jobsOrderByQueues.IsEmpty() {
		job := jobsOrderByQueues.PopNextJob()

		// [Design] 区别于 Reclaim，这里不需要 CanReclaimResources 检查。
		// 因为 Reclaim 是为了纠正“借用”，而 Preempt 是为了“特权”。

		succeeded, statement, preemptedTasksNames := attemptToPreemptForPreemptor(ssn, job)
		if succeeded {
			// [Design: Transaction] 原子性提交抢占结果
			statement.Commit()
		}
	}
}
```

### 4.2 attemptToPreemptForPreemptor：配额检查与模拟

在尝试抢占前，必须先进行配额检查。这一步防止了高优先级作业无限制地滥用资源。

```go
func attemptToPreemptForPreemptor(ssn *framework.Session, preemptor *podgroup_info.PodGroupInfo) (bool, *framework.Statement, []string) {
	// [Design: Plugin Policy] 队列配额预检
	// 由插件（如 Capacity 插件）判断：如果抢占成功，队列资源使用量是否会超过 Quota？
	// 如果会超，则禁止抢占。这保证了 Preempt 不会破坏队列的资源上限。
	if result := ssn.IsNonPreemptibleJobOverQueueQuotaFn(preemptor, preemptorTasks); !result.IsSchedulable {
		return false, nil, nil
	}

	feasibleNodes := common.FeasibleNodesForJob(maps.Values(ssn.Nodes), preemptor)

	// [Design: Simulation]
	// 同样使用 Solver 模式，在内存中构建 Preempt 场景。
	solver := solvers.NewJobsSolver(
		feasibleNodes,
		ssn.PreemptScenarioValidator,
		getOrderedVictimsQueue(ssn, preemptor), // 定义同队列受害者
		framework.Preempt,
	)
	return solver.Solve(ssn, preemptor)
}
```

### 4.3 buildFilterFuncForPreempt：定义的 Victim 过滤

这段代码定义了抢占的“受害者法则”，严格限制了抢占范围。

```go
func buildFilterFuncForPreempt(ssn *framework.Session, preemptor *podgroup_info.PodGroupInfo) func(*podgroup_info.PodGroupInfo) bool {
	return func(job *podgroup_info.PodGroupInfo) bool {
		// [Design: Preempt Rules]
		if !job.IsPreemptibleJob() { return false }

		// 规则 1：只能抢占低优先级 (Lower Priority)
		if job.Priority >= preemptor.Priority { return false }

		// 规则 2：只能抢占同队列 (Same Queue)
		// 这是 Preempt 与 Reclaim 最本质的区别。
		if job.Queue != preemptor.Queue { return false }

		if preemptor.UID == job.UID { return false }
		if job.GetActiveAllocatedTasksCount() == 0 { return false }

		// [Design: Plugin Filter] 额外的插件过滤条件
		if !ssn.PreemptVictimFilter(preemptor, job) { return false }
		return true
	}
}
```

**Preempt Victim 核心条件**：`job.Queue == preemptor.Queue` 且 `job.Priority < preemptor.Priority`。

---

## 5. ByPodSolver：场景模拟（Simulation）与验证

文件：`pkg/scheduler/actions/common/solvers/by_pod_solver.go`

`ByPodSolver` 是设计文档中 **Simulation（模拟）** 机制的具体实现。它在内存中创建一个“平行宇宙”（Scenario），尝试执行“先驱逐、后分配”的操作，并验证最终结果是否合法。

> **[Design: Simulation]** 为什么需要模拟？
> 直接驱逐 Pod 是高风险操作。模拟机制允许调度器在不破坏实际集群状态的情况下，推演“如果我赶走这些 Pod，能不能把那个重要任务放进去？”只有当推演结果完美（资源足够、亲和性满足、且符合公平性校验）时，才会真正 Commit。

### 5.1 solve 主流程

`solve` 方法编排了整个模拟过程：

```go
func (s *byPodSolver) solve(session *framework.Session, scenario *scenario.ByNodeScenario) *solutionResult {
	statement := session.Statement() // 创建新事务，所有操作仅在内存中生效

	// 1. [Virtual Evict] 虚拟驱逐
	// 尝试驱逐已记录的 Victim（之前计算出的潜在受害者）
	// 这步会释放 statement 中的虚拟资源，但不会真的删除 Pod
	err := common.EvictAllPreemptees(session, scenario.RecordedVictimsTasks(), pendingJob, statement, s.actionType)

	// 2. [Search & Expand] 搜索更多 Victim
	// 如果光驱逐已记录的不够，尝试从当前“在这个节点上阻碍我的”最新 Victim 开始，
	// 探索是否驱逐它能腾出空间
	if latestPotentialVictim != nil {
		potentialVictimNodes := getNodesOfJob(latestPotentialVictim)
		// 递归尝试在相关节点上进行模拟
		result, err := s.solveOnPotentialNodes(session, scenario, statement, potentialVictimNodes)
		if result != nil { return result }
	}

	// 3. [Virtual Allocate] 虚拟分配
	// 在假设上述驱逐已发生的基础上，尝试把 Preemptor（抢占者）放进去
	result := s.runSimulation(session, scenario, statement, victimTasks)
	if result != nil {
		return result
	}

	statement.Discard() // 模拟失败，回滚所有内存变更
	return &solutionResult{false, nil, nil, nil}
}
```

### 5.2 tryScenarioWithEvictedVictims：尝试分配

这是“虚拟分配”的核心。它不仅尝试放置 Preemptor，还会处理被驱逐者的后续状态（是彻底驱逐，还是 Pipeline 等待）。

```go
func (s *byPodSolver) tryScenarioWithEvictedVictims(ssn *framework.Session, scenario *scenario.ByNodeScenario,
	statement *framework.Statement, victimTasks []*pod_info.PodInfo) (bool, *simulationVictims, error) {

	// [Design: Virtual Allocate]
	// 调用通用的分配逻辑。注意这里传入了 statement，意味着分配是写入这个临时事务的。
	isSuccessfulAllocations, _ := common.TryToVirtuallyAllocatePreemptorAndGetVictims(
		ssn, statement, nodes, pendingJob, jobsToAllocate, victimTasks)

	if isSuccessfulAllocations {
		actualVictims := newCalculatedVictimsStruct()
		for _, victimTask := range victimTasks {
			// [Design: Evict vs Pipeline]
			// 根据配置和任务状态，决定 Victim 是被直接“杀掉”（Releasing），
			// 还是“暂停”（Pipelined，资源被借用但 Pod 保留，等待将来归还）。
			if victimTask.Status == pod_status.Releasing {
				actualVictims.preemptedVictims = append(...)
			} else if victimTask.Status == pod_status.Pipelined {
				actualVictims.pipelinedVictims = append(...)
			}
		}
		return true, actualVictims, nil
	}
	return false, nil, nil
}
```

### 5.3 handleScenarioSolution：最终校验

模拟成功不代表可以直接提交，还必须通过“校验器”的最后一道关卡。

```go
func (s *byPodSolver) handleScenarioSolution(...) *solutionResult {
	// ... (整理 victimsTasks)

	// [Design: Validation]
	// 调用由 Action 传入的 Validator（例如 PreemptScenarioValidator）。
	// 插件（如 Proportion 插件）会在此处介入：
	// “虽然你可以物理上把这些 Pod 塞进去，但这样做违反了 min-share 公平性原则，所以我否决。”
	if s.solutionValidator != nil {
		validSolution := s.solutionValidator(scenario)
		if !validSolution {
			statement.Discard() // 校验不通过，前功尽弃
			return &solutionResult{false, nil, nil, nil}
		}
	}

	// 一切完美，返回带有 valid statement 的结果，准备 Commit
	return &solutionResult{true, victimsTasks, actualVictimJobs, statement}
}
```

---

## 6. 插件扩展点

### 6.1 Reclaim 相关

| 扩展点                       | 类型                           | 作用                             |
| ---------------------------- | ------------------------------ | -------------------------------- |
| `CanReclaimResourcesFn`      | `func(reclaimer) bool`         | 该 Job 是否允许发起回收          |
| `ReclaimVictimFilter`        | `func(reclaimer, victim) bool` | Victim 是否可被该 Reclaimer 回收 |
| `ReclaimScenarioValidatorFn` | `func(scenario) bool`          | 找到的解是否满足回收策略         |

### 6.2 Preempt 相关

| 扩展点                                | 类型                           | 作用                             |
| ------------------------------------- | ------------------------------ | -------------------------------- |
| `PreemptVictimFilter`                 | `func(preemptor, victim) bool` | Victim 是否可被该 Preemptor 抢占 |
| `PreemptScenarioValidator`            | `func(scenario) bool`          | 找到的解是否满足抢占策略         |
| `IsNonPreemptibleJobOverQueueQuotaFn` | `func(job, tasks) Result`      | 抢占后队列是否超配额             |

### 6.3 典型插件

- **proportion**：`CanReclaimResources`、`ReclaimScenarioValidator`，实现队列公平份额与回收策略。
- **minruntime**：`ReclaimVictimFilter`、`PreemptVictimFilter`、`ReclaimScenarioValidator`、`PreemptScenarioValidator`，避免刚启动的 Job 被抢占。

---

## 7. Evict 的落盘：Cache.Evict → Evictor

当 `statement.Commit()` 执行 `commitEvict` 时：

```go
// framework/session.go
func (ssn *Session) Evict(pod *pod_info.PodInfo, message string, evictionMetadata eviction_info.EvictionMetadata) error {
	ssn.Cache.Evict(pod.Pod, podGroup, evictionMetadata, message)
	// ...
}
```

`Cache.Evict` 内部调用 `Evictor.Evict(evictedPod, message)`，最终通过 Eviction API 或删除 Pod 等方式驱逐，具体实现见 `pkg/scheduler/cache` 下的 Evictor。

---

## 8. 小结：Reclaim vs Preempt

| 项目        | Reclaim                       | Preempt                                 |
| ----------- | ----------------------------- | --------------------------------------- |
| Victim 队列 | 其他队列                      | 同队列                                  |
| 典型用途    | 队列间公平、回收借用          | 队列内优先级                            |
| 前置检查    | CanReclaimResources           | IsNonPreemptibleJobOverQueueQuotaFn     |
| Victim 过滤 | ReclaimVictimFilter           | PreemptVictimFilter（含 Priority 比较） |
| 求解框架    | JobSolver + ByPodSolver       | 同左                                    |
| 落盘        | Evict + Allocate，stmt.Commit | 同左                                    |

二者共享同一套「场景模拟 + Statement 事务」机制，差异主要体现在 Victim 来源与插件策略上。
