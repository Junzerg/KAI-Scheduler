# Reclaim 与 Preempt 走读

本文梳理 KAI Scheduler 中两个「破坏性」调度动作：**Reclaim（回收）** 与 **Preempt（抢占）**。二者均通过驱逐（Evict）已有 Pod 为待调度 Job 腾出资源，但作用域与策略不同。

参考文档：`docs/developer/action-framework-zh.md`、`docs/fairness/README.md`、`docs/queues/README.md`。

---

## 1. Reclaim 与 Preempt 的定位

### 1.1 在 Action 链中的顺序

根据 `action-framework-zh.md`，调度周期内 Action 执行顺序为：

| 顺序 | Action | 作用域 | 干扰程度 |
|------|--------|--------|----------|
| 1 | Allocate | 无 | 无 |
| 2 | Consolidate | 同队列 | 低 |
| 3 | **Reclaim** | **跨队列** | 中 |
| 4 | **Preempt** | **同队列** | 高 |
| 5 | StaleGangEviction | 违反 minMember 的 gang | 高 |

### 1.2 核心区别

| 维度 | Reclaim | Preempt |
|------|---------|---------|
| **Victim 来源** | **其他队列**的 Job | **同一队列**的 Job |
| **设计意图** | 回收「借用」的资源，实现队列间公平 | 队列内按优先级抢占 |
| **典型场景** | 队列 A 超配额借用，队列 B 有更高优先级需求 | 高优先级 Job 抢占低优先级 Job |
| **Victim 过滤** | `ReclaimVictimFilter` | `PreemptVictimFilter` |
| **场景校验** | `ReclaimScenarioValidatorFn` | `PreemptScenarioValidator` |

---

## 2. 共享的求解框架：JobSolver

Reclaim 与 Preempt 均使用 `actions/common/solvers` 包下的 **JobSolver** 与 **ByPodSolver**，通过「场景模拟」寻找可行解。

### 2.1 整体流程

```
Reclaim/Preempt Execute
    │
    ▼
for each pending Job (按队列顺序):
    │
    ├─ Reclaim: CanReclaimResources(job)?  [仅 Reclaim]
    ├─ Preempt: IsNonPreemptibleJobOverQueueQuotaFn?  [仅 Preempt]
    │
    ▼
solver.Solve(ssn, job)
    │
    ├─ 逐 Task 尝试：从 1 个 Task 到全部 Task
    ├─ 对每个 partialJob：solvePartialJob
    │       │
    │       ├─ ScenarioBuilder 生成 Victim 组合（ByNodeScenario）
    │       ├─ 对每个 Scenario：ByPodSolver.solve
    │       │       │
    │       │       ├─ EvictAllPreemptees（虚拟驱逐 Victim）
    │       │       ├─ TryToVirtuallyAllocatePreemptorAndGetVictims（虚拟分配 Preemptor + 被抢占的 Victim）
    │       │       └─ solutionValidator(scenario) 校验
    │       │
    │       └─ 找到可行解 → 返回 statement
    │
    ▼
statement.Commit()  →  Evict + Allocate 落盘
```

### 2.2 JobSolver.Solve 入口

文件：`pkg/scheduler/actions/common/solvers/job_solver.go`

```go
func (s *JobSolver) Solve(ssn *framework.Session, pendingJob *podgroup_info.PodGroupInfo) (bool, *framework.Statement, []string) {
	tasksToAllocate := podgroup_info.GetTasksToAllocate(pendingJob, ssn.PodSetOrderFn, ssn.TaskOrderFn, false)
	for _, nextTaskToSolve := range tasksToAllocate {
		pendingTasks = append(pendingTasks, nextTaskToSolve)
		partialPendingJob := getPartialJobRepresentative(pendingJob, pendingTasks)
		result := s.solvePartialJob(ssn, &state, partialPendingJob)
		if result != nil && result.solved {
			statement = result.statement
			// ...
		}
	}
	jobSolved := pendingJob.IsGangSatisfied()
	return jobSolved, statement, calcVictimNames(state.recordedVictimsTasks)
}
```

**逐 Task 尝试**：先尝试只分配 1 个 Task，再 2 个、3 个…直到全部分配或失败。支持 gang 的部分满足。

---

## 3. Reclaim 动作详解

文件：`pkg/scheduler/actions/reclaim/reclaim.go`

### 3.1 Execute 主循环

```go
func (ra *reclaimAction) Execute(ssn *framework.Session) {
	jobsOrderByQueues := utils.NewJobsOrderByQueues(ssn, utils.JobsOrderInitOptions{
		FilterNonPending: true, FilterUnready: true,
		MaxJobsQueueDepth: ssn.GetJobsDepth(framework.Reclaim),
	})
	jobsOrderByQueues.InitializeWithJobs(ssn.PodGroupInfos)

	for !jobsOrderByQueues.IsEmpty() {
		job := jobsOrderByQueues.PopNextJob()
		if !ssn.CanReclaimResources(job) {
			continue  // 插件判断：该 Job 所在队列是否允许回收
		}
		// SchedulingSignatures：跳过「不比已失败 Job 更容易调度」的 Job
		if ssn.UseSchedulingSignatures() {
			easier, otherJob := smallestFailedJobs.IsEasierToSchedule(job)
			if !easier { continue }
		}
		succeeded, statement, reclaimeeTasksNames := ra.attemptToReclaimForSpecificJob(ssn, job)
		if succeeded {
			statement.Commit()
		} else {
			smallestFailedJobs.UpdateRepresentative(job)
		}
	}
}
```

### 3.2 attemptToReclaimForSpecificJob

```go
func (ra *reclaimAction) attemptToReclaimForSpecificJob(ssn *framework.Session, reclaimer *podgroup_info.PodGroupInfo) (bool, *framework.Statement, []string) {
	feasibleNodes := common.FeasibleNodesForJob(maps.Values(ssn.Nodes), reclaimer)
	solver := solvers.NewJobsSolver(
		feasibleNodes,
		ssn.ReclaimScenarioValidatorFn,
		getOrderedVictimsQueue(ssn, reclaimer),
		framework.Reclaim,
	)
	return solver.Solve(ssn, reclaimer)
}
```

### 3.3 getOrderedVictimsQueue：Reclaim 的 Victim 来源

```go
func getOrderedVictimsQueue(ssn *framework.Session, reclaimer *podgroup_info.PodGroupInfo) solvers.GenerateVictimsQueue {
	return func() *utils.JobsOrderByQueues {
		jobsOrderedByQueue := utils.NewJobsOrderByQueues(ssn, utils.JobsOrderInitOptions{
			FilterNonPreemptible:     true,   // 只考虑可抢占的 Job
			FilterNonActiveAllocated: true,   // 只考虑有已分配 Pod 的 Job
			VictimQueue:              true,
			MaxJobsQueueDepth:        scheduler_util.QueueCapacityInfinite,
		})
		jobs := map[common_info.PodGroupID]*podgroup_info.PodGroupInfo{}
		for _, job := range ssn.PodGroupInfos {
			if job.Queue == reclaimer.Queue {
				continue  // 关键：排除同队列，只从其他队列选 Victim
			}
			if !ssn.ReclaimVictimFilter(reclaimer, job) {
				continue
			}
			jobs[job.UID] = job
		}
		jobsOrderedByQueue.InitializeWithJobs(jobs)
		return &jobsOrderedByQueue
	}
}
```

**Reclaim Victim 条件**：`job.Queue != reclaimer.Queue`，即 **跨队列**。

---

## 4. Preempt 动作详解

文件：`pkg/scheduler/actions/preempt/preempt.go`

### 4.1 Execute 主循环

```go
func (alloc *preemptAction) Execute(ssn *framework.Session) {
	// 与 Reclaim 类似：JobsOrderByQueues、SchedulingSignatures
	for !jobsOrderByQueues.IsEmpty() {
		job := jobsOrderByQueues.PopNextJob()
		// 无 CanReclaimResources 检查
		succeeded, statement, preemptedTasksNames := attemptToPreemptForPreemptor(ssn, job)
		if succeeded {
			statement.Commit()
		}
	}
}
```

### 4.2 attemptToPreemptForPreemptor

```go
func attemptToPreemptForPreemptor(ssn *framework.Session, preemptor *podgroup_info.PodGroupInfo) (bool, *framework.Statement, []string) {
	// 队列配额检查：抢占后是否超配额
	if result := ssn.IsNonPreemptibleJobOverQueueQuotaFn(preemptor, preemptorTasks); !result.IsSchedulable {
		return false, nil, nil
	}
	feasibleNodes := common.FeasibleNodesForJob(maps.Values(ssn.Nodes), preemptor)
	solver := solvers.NewJobsSolver(
		feasibleNodes,
		ssn.PreemptScenarioValidator,
		getOrderedVictimsQueue(ssn, preemptor),
		framework.Preempt,
	)
	return solver.Solve(ssn, preemptor)
}
```

### 4.3 buildFilterFuncForPreempt：Preempt 的 Victim 过滤

```go
func buildFilterFuncForPreempt(ssn *framework.Session, preemptor *podgroup_info.PodGroupInfo) func(*podgroup_info.PodGroupInfo) bool {
	return func(job *podgroup_info.PodGroupInfo) bool {
		if !job.IsPreemptibleJob() { return false }
		if job.Priority >= preemptor.Priority { return false }  // 只能抢占低优先级
		if job.Queue != preemptor.Queue { return false }       // 关键：同队列
		if preemptor.UID == job.UID { return false }
		if job.GetActiveAllocatedTasksCount() == 0 { return false }
		if !ssn.PreemptVictimFilter(preemptor, job) { return false }
		return true
	}
}
```

**Preempt Victim 条件**：`job.Queue == preemptor.Queue`，即 **同队列**，且 `job.Priority < preemptor.Priority`。

---

## 5. ByPodSolver：场景模拟与 Evict + Allocate

文件：`pkg/scheduler/actions/common/solvers/by_pod_solver.go`

### 5.1 solve 主流程

```go
func (s *byPodSolver) solve(session *framework.Session, scenario *scenario.ByNodeScenario) *solutionResult {
	statement := session.Statement()
	pendingJob := scenario.GetPreemptor()
	latestPotentialVictim := scenario.LatestPotentialVictim()

	// 1. 虚拟驱逐已记录的 Victim
	err := common.EvictAllPreemptees(session, scenario.RecordedVictimsTasks(), pendingJob, statement, s.actionType)

	// 2. 若有新的潜在 Victim，从其所在节点尝试
	if latestPotentialVictim != nil {
		potentialVictimNodes := getNodesOfJob(latestPotentialVictim)
		result, err := s.solveOnPotentialNodes(session, scenario, statement, potentialVictimNodes)
		// ...
	}

	// 3. 尝试在「已驱逐 Victim 释放的资源」上分配 Preemptor
	result := s.runSimulation(session, scenario, statement, victimTasks)
	// ...
}
```

### 5.2 tryScenarioWithEvictedVictims：虚拟分配

```go
func (s *byPodSolver) tryScenarioWithEvictedVictims(ssn *framework.Session, scenario *scenario.ByNodeScenario,
	statement *framework.Statement, victimTasks []*pod_info.PodInfo) (bool, *simulationVictims, error) {
	pendingJob := scenario.GetPreemptor()
	nodes := maps.Values(s.feasibleNodes)
	jobsToAllocate := common.GetJobsToAllocate(ssn, victimTasks, pendingJob)

	// 虚拟分配：Preemptor + 被抢占的 Victim Job（可能部分 Pipeline）
	isSuccessfulAllocations, _ := common.TryToVirtuallyAllocatePreemptorAndGetVictims(
		ssn, statement, nodes, pendingJob, jobsToAllocate, victimTasks)

	if isSuccessfulAllocations {
		actualVictims := newCalculatedVictimsStruct()
		for _, victimTask := range victimTasks {
			if victimTask.Status == pod_status.Releasing {
				actualVictims.preemptedVictims = append(...)  // 真正驱逐
			} else if victimTask.Status == pod_status.Pipelined {
				actualVictims.pipelinedVictims = append(...)  // Pipeline
			}
		}
		return true, actualVictims, nil
	}
	return false, nil, nil
}
```

**Evict vs Pipeline**：部分 Victim 可能被 Pipeline（在待驱逐资源上预占），而非直接 Evict，取决于 `AllowConsolidatingReclaim` 等配置。

### 5.3 solutionValidator

找到可行解后，调用 `ReclaimScenarioValidatorFn` 或 `PreemptScenarioValidator` 做最终校验（如 proportion 插件的公平性、minruntime 等）。

---

## 6. 插件扩展点

### 6.1 Reclaim 相关

| 扩展点 | 类型 | 作用 |
|--------|------|------|
| `CanReclaimResourcesFn` | `func(reclaimer) bool` | 该 Job 是否允许发起回收 |
| `ReclaimVictimFilter` | `func(reclaimer, victim) bool` | Victim 是否可被该 Reclaimer 回收 |
| `ReclaimScenarioValidatorFn` | `func(scenario) bool` | 找到的解是否满足回收策略 |

### 6.2 Preempt 相关

| 扩展点 | 类型 | 作用 |
|--------|------|------|
| `PreemptVictimFilter` | `func(preemptor, victim) bool` | Victim 是否可被该 Preemptor 抢占 |
| `PreemptScenarioValidator` | `func(scenario) bool` | 找到的解是否满足抢占策略 |
| `IsNonPreemptibleJobOverQueueQuotaFn` | `func(job, tasks) Result` | 抢占后队列是否超配额 |

### 6.3 典型插件

- **proportion**：`CanReclaimResources`、`ReclaimScenarioValidator`，实现队列公平份额与回收策略。
- **minruntime**：`ReclaimVictimFilter`、`PreemptVictimFilter`、`ReclaimScenarioValidator`、`PreemptScenarioValidator`，避免刚启动的 Job 被抢占。

---

## 7. Evict 的落盘：Cache.Evict → Evictor

当 `statement.Commit()` 执行 `commitEvict` 时：

```go
// framework/session.go
func (ssn *Session) Evict(pod *pod_info.PodInfo, message string, evictionMetadata eviction_info.EvictionMetadata) error {
	ssn.Cache.Evict(pod.Pod, podGroup, evictionMetadata, message)
	// ...
}
```

`Cache.Evict` 内部调用 `Evictor.Evict(evictedPod, message)`，最终通过 Eviction API 或删除 Pod 等方式驱逐，具体实现见 `pkg/scheduler/cache` 下的 Evictor。

---

## 8. 小结：Reclaim vs Preempt

| 项目 | Reclaim | Preempt |
|------|---------|---------|
| Victim 队列 | 其他队列 | 同队列 |
| 典型用途 | 队列间公平、回收借用 | 队列内优先级 |
| 前置检查 | CanReclaimResources | IsNonPreemptibleJobOverQueueQuotaFn |
| Victim 过滤 | ReclaimVictimFilter | PreemptVictimFilter（含 Priority 比较） |
| 求解框架 | JobSolver + ByPodSolver | 同左 |
| 落盘 | Evict + Allocate，stmt.Commit | 同左 |

二者共享同一套「场景模拟 + Statement 事务」机制，差异主要体现在 Victim 来源与插件策略上。
