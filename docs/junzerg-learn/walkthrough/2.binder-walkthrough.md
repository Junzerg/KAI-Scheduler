# Binder 走读：从 Statement.Commit 到 Pod 绑定

本文承接 `1.scheduler-entry-and-allocate-walkthrough.md`，梳理调度器决策落盘后的完整链路：**Statement.Commit** → **BindRequest 创建** → **Binder 处理** → **Pod 实际绑定**。

参考文档：`docs/developer/binder-zh.md`、`docs/junzerg-learn/services-architecture.md`。

---

## 1. 整体数据流

```
Scheduler (runOnce)
    │
    │  action.Execute(ssn)  →  stmt.Allocate(task, node)  [内存模拟]
    │
    ▼
stmt.Commit()
    │
    ├─ commitAllocate  →  ssn.BindPod(task)  →  ssn.Cache.Bind(...)
    │                          │
    │                          ▼
    │                    SchedulerCache.createBindRequest()  →  API Server 创建 BindRequest CRD
    │
    ├─ commitEvict     →  ssn.Evict(task, ...)  →  ssn.Cache.Evict(...)  [Reclaim/Preempt 场景]
    │
    └─ commitPipeline →  StatusUpdater.Pipelined(...)  [Pipeline 场景，不创建 BindRequest]
    │
    ▼
Binder 控制器（独立进程）
    │
    │  Watch BindRequest  →  Reconcile  →  binder.Bind(pod, node, bindRequest)
    │
    ▼
Pod 绑定到 Node（kubeClient.SubResource("binding").Create）
```

**关键点**：调度器与 Binder 通过 **BindRequest CRD** 解耦。调度器只负责创建 BindRequest，Binder 异步执行绑定，支持重试、错误恢复。

---

## 2. Statement.Commit 与操作类型

文件：`pkg/scheduler/framework/statement.go`

### 2.1 Statement 结构

```go
type Statement struct {
	operations []Operation  // 本 Statement 累积的 Allocate/Evict/Pipeline 操作
	ssn        *Session
	sessionID  string
}
```

每个 Action（Allocate、Reclaim、Preempt 等）在内存中通过 `stmt.Allocate`、`stmt.Evict`、`stmt.Pipeline` 累积操作，**不直接写集群**。只有 `stmt.Commit()` 才将操作落盘。

### 2.2 Commit 流程

```go
func (s *Statement) Commit() error {
	for i, op := range s.operations {
		switch op.Name() {
		case evict:
			err = s.commitEvict(taskInfo, evictOp)
		case pipeline:
			s.commitPipeline(taskInfo, op.(pipelineOperation).message)
		case allocate:
			err = s.commitAllocate(taskInfo)
		}
	}
	s.clearOperations()
	return err
}
```

| 操作类型     | 对应方法         | 作用                                            |
| ------------ | ---------------- | ----------------------------------------------- |
| **allocate** | `commitAllocate` | 创建 BindRequest，将 Pod 绑定到节点             |
| **evict**    | `commitEvict`    | 驱逐 Pod，释放资源（Reclaim/Preempt 场景）      |
| **pipeline** | `commitPipeline` | 仅更新 Pod 状态为 Pipelined，不创建 BindRequest |

---

## 3. commitAllocate：从 Session 到 Cache.Bind

### 3.1 commitAllocate → BindPod

```go
func (s *Statement) commitAllocate(task *pod_info.PodInfo) error {
	hostname := task.NodeName
	node, found := s.ssn.Nodes[hostname]
	// ...
	if err = s.ssn.BindPod(task); err != nil {
		// ...
	}
	return err
}
```

### 3.2 Session.BindPod

文件：`pkg/scheduler/framework/session.go`

```go
func (ssn *Session) BindPod(pod *pod_info.PodInfo) error {
	bindRequestAnnotations := ssn.MutateBindRequestAnnotations(pod, pod.NodeName)
	if err := ssn.Cache.Bind(pod, pod.NodeName, bindRequestAnnotations); err != nil {
		return err
	}
	if err := ssn.updatePodOnSession(pod, pod_status.Binding); err != nil {
		// ...
	}
	return nil
}
```

- **MutateBindRequestAnnotations**：插件可在此修改 BindRequest 的 Annotations（见 `docs/developer/designs/bindrequest-mutations/README-zh.md`）。
- **Cache.Bind**：实际创建 BindRequest 并更新 Pod 状态。

---

## 4. SchedulerCache.Bind 与 createBindRequest

文件：`pkg/scheduler/cache/cache.go`

### 4.1 Bind 方法

```go
func (sc *SchedulerCache) Bind(taskInfo *pod_info.PodInfo, hostname string, bindRequestAnnotations map[string]string) error {
	sc.StatusUpdater.PreBind(taskInfo.Pod)
	if bindRequestError := sc.createBindRequest(taskInfo, hostname, bindRequestAnnotations); bindRequestError != nil {
		return sc.StatusUpdater.Bound(taskInfo.Pod, hostname, bindRequestError, sc.getNodPoolName())
	}
	labelsPatch := sc.nodePoolLabelsChange(taskInfo.Pod.Labels)
	if len(labelsPatch) > 0 {
		sc.StatusUpdater.PatchPodLabels(taskInfo.Pod, labelsPatch)
	}
	return sc.StatusUpdater.Bound(taskInfo.Pod, hostname, nil, sc.getNodPoolName())
}
```

- **PreBind**：更新 Pod 状态（如 Pending → Binding）。
- **createBindRequest**：创建 BindRequest CRD。
- **Bound**：记录绑定结果到 Pod Condition。

### 4.2 createBindRequest：BindRequest CRD 结构

```go
func (sc *SchedulerCache) createBindRequest(podInfo *pod_info.PodInfo, nodeName string, bindRequestAnnotations map[string]string) error {
	bindRequest := &schedulingv1alpha2.BindRequest{
		ObjectMeta: metav1.ObjectMeta{
			Name:      podInfo.Pod.Name,
			Namespace: podInfo.Namespace,
			OwnerReferences: []metav1.OwnerReference{{
				APIVersion: "v1", Kind: "Pod", Name: podInfo.Pod.Name, UID: podInfo.Pod.UID,
			}},
			Annotations: bindRequestAnnotations,
			Labels:      labels,  // pod-name, selected-node, node pool 等
		},
		Spec: schedulingv1alpha2.BindRequestSpec{
			PodName:              podInfo.Name,
			SelectedNode:         nodeName,
			SelectedGPUGroups:    podInfo.GPUGroups,           // 分式 GPU 场景
			ReceivedResourceType: string(podInfo.ResourceReceivedType),
			ReceivedGPU:           &schedulingv1alpha2.ReceivedGPU{...},
			ResourceClaimAllocations: podInfo.ResourceClaimInfo,  // DRA 场景
		},
	}
	_, err := sc.kubeAiSchedulerClient.SchedulingV1alpha2().BindRequests(podInfo.Namespace).Create(context.TODO(), bindRequest, metav1.CreateOptions{})
	return err
}
```

**BindRequest 字段说明**：

| 字段                     | 含义                                         |
| ------------------------ | -------------------------------------------- |
| PodName / SelectedNode   | 待绑定 Pod 与目标节点                        |
| SelectedGPUGroups        | 分式 GPU 场景下的 GPU 组                     |
| ResourceClaimAllocations | DRA（动态资源分配）的 ResourceClaim 分配结果 |
| BackoffLimit             | 绑定失败时的重试次数（可选）                 |

---

## 5. Binder 进程入口与控制器

### 5.1 进程入口

文件：`cmd/binder/main.go`（若存在）或 `cmd/binder/app/app.go`

Binder 是**独立二进制**，与 Scheduler 分开部署。通过 Operator 或 Helm 部署时，Binder 作为独立 Deployment 运行。

### 5.2 App.Run：基础设施初始化

在启动核心逻辑前，Binder 需初始化管理器（Manager）和资源预留服务（RRS），这对应设计文档中提到的**独立控制器**所需的运行时环境。

```go
// cmd/binder/app/app.go

// 1. 初始化 Manager (包含 Leader Election, Metrics Server)
mgr, err := ctrl.NewManager(config, ctrl.Options{...})

// 2. 启动 Resource Reservation Service 同步
// [Design] 独立维护 GPU 等资源预留状态，不依赖调度器缓存
go func() {
    app.rrs.Sync(context.Background())
}()
```

### 5.3 注册控制器

Binder 进程包含两个关键控制器，分别负责“绑定”与“清理”，确保状态闭环。

```go
// cmd/binder/app/app.go

// [Controller 1] PodReconciler
// 监听 Pod 删除/完成事件，负责清理 RRS 中的过期预留
(&controllers.PodReconciler{...}).SetupWithManager(app.manager, app.reconcilerParams)

// 实例化 Binder 核心对象
// [Design] 注入 Plugins，支持 VolumeBinding, DRA 等扩展逻辑
binder := binding.NewBinder(app.Client, app.rrs, app.plugins)

// [Controller 2] BindRequestReconciler
// 核心链路：监听 BindRequest 触发绑定
reconciler := controllers.NewBindRequestReconciler(
	app.manager.GetClient(),
	app.manager.GetScheme(),
	app.manager.GetEventRecorderFor("binder"),
	app.reconcilerParams,
	binder,  // 注入 Binder 执行逻辑
	app.rrs)
reconciler.SetupWithManager(app.manager)
```

- **Binder 实例**：封装实际的绑定动作（如调用 Kubernetes API、执行插件）。
- **BindRequestReconciler**：**[Design Interface]** 实现与调度器的解耦，只响应 `BindRequest` CRD。

---

## 6. BindRequestReconciler.Reconcile

文件：`pkg/binder/controllers/bindrequest_controller.go`

【设计文档 binder-zh】Reconcile 实现 binder-zh 中「绑定过程」的 2–4 步：监听 BindRequest → 获取 Pod/Node → 执行绑定 → 更新状态。与调度器通过 BindRequest 解耦，Binder 独立处理绑定与重试。

### 6.1 主流程

```go
func (r *BindRequestReconciler) Reconcile(ctx context.Context, req ctrl.Request) (result ctrl.Result, err error) {
	// 1. 获取 BindRequest
	if err = r.Client.Get(ctx, req.NamespacedName, bindRequest); err != nil {
		return result, client.IgnoreNotFound(err)
	}
	if bindRequest.DeletionTimestamp != nil { return result, nil }
	if bindRequest.Status.Phase == schedulingv1alpha2.BindRequestPhaseSucceeded { return result, nil }

	// 2. 获取 Pod
	if err = r.Client.Get(ctx, client.ObjectKeyFromObject(pod), pod); err != nil { return result, err }
	if pod.Spec.NodeName != "" {
		// Pod 已绑定，跳过
		return result, nil
	}

	// 3. 获取 Node
	if err = r.Client.Get(ctx, client.ObjectKeyFromObject(node), node); err != nil { return result, err }

	// 4. 执行绑定
	err = r.binder.Bind(ctx, pod, node, bindRequest)

	// 5. 更新 BindRequest 状态、Pod Condition（在 defer 中）
	return result, err
}
```

- **defer**：无论成功或失败，都会执行 `UpdateStatus` 和 `updatePodCondition`，保证 BindRequest 状态与 Pod Condition 与 binder-zh 中「更新 BindRequest 状态以反映成功或失败」一致。
- **Pod 已绑定跳过**：若 `pod.Spec.NodeName != ""`，说明已被其他途径绑定，直接返回，避免重复绑定。

### 6.2 错误处理与重试

【设计文档 binder-zh】对应 binder-zh「错误处理」：绑定失败需记录、可重试，最终失败则标记 BindRequest 为失败以便调度器重新调度。

- 绑定失败时：`bindRequest.Status.Phase = BindRequestPhaseFailed`，`Status.Reason = err.Error()`。
- 若配置了 `BackoffLimit`：`RequeueAfter = (1 << FailedAttempts) * time.Second`，指数退避重试（实现位于 `UpdateStatus`）。
- 成功时：`Phase = BindRequestPhaseSucceeded`，后续 Reconcile 直接返回。

---

## 7. Binder.Bind：实际绑定逻辑

文件：`pkg/binder/binding/binder.go`

### 7.1 主流程

```go
func (b *Binder) Bind(ctx context.Context, pod *v1.Pod, node *v1.Node, bindRequest *v1alpha2.BindRequest) error {
	// 1. 同步节点上的 ResourceReservation 状态（分式 GPU 等）
	err := b.resourceReservationService.SyncForNode(ctx, bindRequest.Spec.SelectedNode)

	// 2. 分式 GPU：预留 GPU 设备
	var reservedGPUIds []string
	if common.IsSharedGPUAllocation(bindRequest) {
		reservedGPUIds, err = b.reserveGPUs(ctx, pod, bindRequest)
		if err != nil { return err }
	}

	// 3. PreBind 插件：卷绑定、DRA 等前置操作
	bindingState := &state.BindingState{ReservedGPUIds: reservedGPUIds}
	err = b.plugins.PreBind(ctx, pod, node, bindRequest, bindingState)
	if err != nil { return err }

	// 4. 打补丁：ResourceReceivedType 等注解
	err = b.patchResourceReceivedTypeAnnotation(ctx, pod, bindRequest)

	// 5. 调用 Kubernetes 绑定 API
	binding := &v1.Binding{
		ObjectMeta: metav1.ObjectMeta{Namespace: pod.Namespace, Name: pod.Name, UID: pod.UID},
		Target:     v1.ObjectReference{Kind: "Node", Name: node.Name},
	}
	err = b.kubeClient.SubResource("binding").Create(ctx, pod, binding)

	// 6. PostBind 插件：清理、日志等
	b.plugins.PostBind(ctx, pod, node, bindRequest, bindingState)
	return nil
}
```

### 7.2 绑定 API

`b.kubeClient.SubResource("binding").Create(ctx, pod, binding)` 等价于对 Pod 发起 `POST /api/v1/namespaces/{ns}/pods/{name}/binding`，将 `spec.nodeName` 写入 Pod，完成调度器到 kubelet 的最后一环。

---

## 8. Binder 插件

参考：`docs/developer/binder-zh.md`「扩展 Binder」。

### 8.1 插件接口

```go
type Plugin interface {
	Name() string
	Validate(*v1.Pod) error
	Mutate(*v1.Pod) error
	PreBind(ctx context.Context, pod *v1.Pod, node *v1.Node, bindRequest *v1alpha2.BindRequest, state *state.BindingState) error
	PostBind(ctx context.Context, pod *v1.Pod, node *v1.Node, bindRequest *v1alpha2.BindRequest, state *state.BindingState)
}
```

### 8.2 典型插件

| 插件                       | 职责                                                            |
| -------------------------- | --------------------------------------------------------------- |
| **VolumeBinding**          | 处理 PVC/PV 绑定，确保卷可用后再绑定 Pod                        |
| **DynamicResources (DRA)** | 处理 ResourceClaim 分配，更新 ResourceClaim 的 AllocationResult |
| **GPUSharing**             | 分式 GPU 场景下的设备预留与注解                                 |

PreBind 在 `SubResource("binding").Create` **之前**执行，可完成卷、DRA、GPU 预留等依赖；PostBind 在**之后**执行，用于清理或记录。

---

## 9. Evict 与 Pipeline 的差异

### 9.1 commitEvict

Reclaim、Preempt 等 Action 会调用 `stmt.Evict(victimTask, message, evictionMetadata)`。Commit 时：

```go
// statement.go 中 commitEvict 调用
ssn.Evict(taskInfo, evictOp.message, evictOp.evictionMetadata)
```

Session.Evict 内部调用 `ssn.Cache.Evict(pod.Pod, podGroup, evictionMetadata, message)`，最终由 **Evictor** 执行驱逐（如调用 Eviction API 或删除 Pod，取决于配置）。

### 9.2 commitPipeline

Pipeline 表示「在待驱逐资源上预占位」：Pod 被标记为将来可调度到某节点，但资源尚未真正释放，**不创建 BindRequest**。Commit 时仅更新 Pod 状态为 Pipelined，等资源释放后，下一调度周期可能转为 Allocate。

---

## 10. 小结：Binder 链路回顾

| 阶段 | 组件           | 关键动作                                                       |
| ---- | -------------- | -------------------------------------------------------------- |
| 1    | Scheduler      | `stmt.Commit()` → `commitAllocate` → `ssn.BindPod`             |
| 2    | Session        | `BindPod` → `Cache.Bind` + `MutateBindRequestAnnotations`      |
| 3    | SchedulerCache | `createBindRequest` → 创建 BindRequest CRD                     |
| 4    | Binder 控制器  | Watch BindRequest → `Reconcile` → `binder.Bind`                |
| 5    | Binder         | PreBind 插件 → `SubResource("binding").Create` → PostBind 插件 |

**设计优势**：调度器与绑定解耦，绑定失败可重试，不阻塞调度循环；DRA、卷、分式 GPU 等复杂逻辑由 Binder 插件处理。
